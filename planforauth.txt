📌 accounts/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta
import random

class OneTimePassword(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    code = models.CharField(max_length=6)
    created_at = models.DateTimeField(auto_now_add=True)

    def is_expired(self):
        return timezone.now() > self.created_at + timedelta(minutes=10)

    @staticmethod
    def generate_code():
        return str(random.randint(100000, 999999))

📌 accounts/forms.py
from django import forms
from django.contrib.auth.models import User

class RegisterForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput)
    class Meta:
        model = User
        fields = ['username', 'email', 'password']

class OTPForm(forms.Form):
    otp = forms.CharField(max_length=6, required=True, label="Enter OTP")

📌 accounts/views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from django.core.mail import send_mail
from django.contrib.auth.models import User
from django.conf import settings

from .forms import RegisterForm, OTPForm
from .models import OneTimePassword

# Register View
def register(request):
    if request.method == "POST":
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.set_password(form.cleaned_data['password'])
            user.is_active = False
            user.save()

            # Generate OTP
            code = OneTimePassword.generate_code()
            OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

            # Send OTP via email
            send_mail(
                "Verify your Triple G account",
                f"Your OTP code is {code}. It will expire in 10 minutes.",
                settings.DEFAULT_FROM_EMAIL,
                [user.email],
                fail_silently=False,
            )

            messages.info(request, "Account created! Please verify with the OTP sent to your email.")
            request.session['pending_user_id'] = user.id
            return redirect("verify_otp")
    else:
        form = RegisterForm()
    return render(request, "accounts/register.html", {"form": form})


# OTP Verification View
def verify_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    otp_obj = OneTimePassword.objects.filter(user=user).first()

    if request.method == "POST":
        form = OTPForm(request.POST)
        if form.is_valid():
            code = form.cleaned_data['otp']
            if otp_obj and otp_obj.code == code and not otp_obj.is_expired():
                user.is_active = True
                user.save()
                otp_obj.delete()
                messages.success(request, "Account verified! You can now log in.")
                return redirect("login")
            else:
                messages.error(request, "Invalid or expired OTP.")
    else:
        form = OTPForm()
    return render(request, "accounts/verify_otp.html", {"form": form, "email": user.email})


# Resend OTP View
def resend_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    code = OneTimePassword.generate_code()
    OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

    send_mail(
        "Resend OTP - Triple G account",
        f"Your new OTP code is {code}. It will expire in 10 minutes.",
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        fail_silently=False,
    )

    messages.success(request, "A new OTP has been sent to your email.")
    return redirect("verify_otp")

📌 accounts/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("register/", views.register, name="register"),
    path("verify-otp/", views.verify_otp, name="verify_otp"),
    path("resend-otp/", views.resend_otp, name="resend_otp"),
]

📌 templates/accounts/register.html
<h2>Create Account</h2>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Register</button>
</form>

📌 templates/accounts/verify_otp.html
<h2>Verify Account</h2>
<p>We sent an OTP to your email: {{ email }}</p>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Verify</button>
</form>

<p>Didn't receive the code? 
   <a href="{% url 'resend_otp' %}">Resend OTP</a>
</p>

📌 settings.py (Email setup for OTP)

Add this for email sending (use Gmail SMTP or service like SendGrid, Mailgun):

# Example: Gmail SMTP
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = "your-email@gmail.com"
EMAIL_HOST_PASSWORD = "your-app-password"  # Use app password, not your raw Gmail password
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER

🔒 Security Checklist

OTP expires in 10 minutes.

OTP is deleted once used.

Prevent brute force → consider libraries like django-axes.

Always deploy over HTTPS.

Emails should use App Passwords / secure SMTP.

✅ This gives you:

Register → inactive user created

OTP emailed

Verify OTP → activate user

Resend OTP option













📌 Descriptive Plan for Secure Registration with OTP Verification
1. User Registration Flow

A new user fills out the registration form (username, email, password).

When the form is submitted:

The password is hashed using Django’s set_password() method.

The user account is created but marked as inactive (user.is_active = False).

An OTP code is generated (6 digits, random).

The OTP is stored in the OneTimePassword model linked to the user.

An email is sent to the user with the OTP code and a message that it expires in 10 minutes.

The system saves the user’s ID in the session (request.session['pending_user_id']) so the verification step knows which user is pending activation.

2. OTP Verification Flow

The user is redirected to the OTP verification page.

They enter the OTP code into the form.

When submitted:

The system checks:

If the OTP exists for the user.

If the code matches.

If the OTP is not expired (older than 10 minutes → rejected).

If valid:

The user account is activated (user.is_active = True).

The OTP record is deleted from the database.

The user receives a success message and is redirected to the login page.

If invalid or expired:

An error message is shown (Invalid or expired OTP).

3. Resend OTP Flow

If the user doesn’t receive the OTP or it expires:

They click “Resend OTP” on the verification page.

A new 6-digit OTP is generated and updated in the database.

A new email is sent with the updated code.

The old code is automatically replaced.

The user is redirected back to the verification page with a success message.

4. Security Features

🔐 OTP Expiry → Each OTP is valid only for 10 minutes.

🔐 OTP Deletion → Once successfully used, the OTP record is deleted.

🔐 Inactive Until Verified → Users cannot log in until they successfully verify with OTP.

🔐 Brute Force Protection → Add optional libraries like:

django-axes (blocks repeated failed login attempts).

Rate limiting OTP verification attempts.

🔐 Secure Email Delivery →

Use Gmail App Passwords or services like SendGrid/Mailgun.

Never store plain email passwords in the code.

🔐 Transport Security → Always deploy with HTTPS (TLS) so credentials/OTPs aren’t intercepted.

5. User Experience (UX)

✅ Clear messages guide the user through registration and verification.

✅ Resend OTP option prevents frustration if an email is delayed.

✅ Success message after activation confirms account is ready.

✅ Minimal fields in the register form make it simple for users.

6. Future Improvements (Optional Enhancements)

📱 Add SMS OTP using services like Twilio for better reach.

🔄 Add Backup Verification (e.g., recovery email, secret questions).

📊 Track verification attempts to detect unusual activity.

🕒 Allow users to request OTP only after a cooldown (e.g., 30s – 1min) to prevent spamming.

🛡 Use reCAPTCHA on registration to reduce bot signups.

✅ Summary:
Your system will:

Register users as inactive.

Send OTP to email.

Require OTP verification before login.

Allow resending of OTP if needed.

Protect against brute force & ensure secure delivery.

---

### 🚀 Enhancements & Best Practices (Recommended)

**Brute Force Protection:**
- Implement libraries like `django-axes` to block repeated failed login or OTP attempts.
- Consider rate limiting OTP verification and resend attempts.

**Rate Limiting for OTP Resend:**
- Add a cooldown (e.g., 30–60 seconds) before a user can request another OTP.

**Logging & Monitoring:**
- Log failed OTP and login attempts for auditing and possible lockout after repeated failures.

**Email Improvements:**
- Use Django’s templated emails for branded, user-friendly OTP messages.
- Consider adding a warning if an OTP is about to expire.

**Testing:**
- Add automated tests for registration, OTP expiry, resend, and verification flows.

**User Feedback:**
- Alert users if they are close to OTP expiry or have requested too many resends.

**SMS Option (Optional):**
- Add SMS OTP using services like Twilio for broader reach.

**Backup Verification:**
- Consider supporting backup email or secret questions for account recovery.

**Cool-down for OTP Requests:**
- Prevent spamming by enforcing a delay between OTP requests.

**reCAPTCHA:**
- Add reCAPTCHA to registration to reduce bot signups.

**Transport Security:**
- Always deploy with HTTPS (TLS) to protect credentials and OTPs in transit.

**Summary:**
These enhancements will make your authentication system even more robust, user-friendly, and secure for production environments.


---

## 📌 Adminside Authentication Plan (`accounts/templates/admin/`)

### 1. **Admin Registration Flow**
- **User fills out registration form** with first name, last name, email, password, and confirms password.
- **Terms and Privacy Policy** agreement required.
- **Password strength meter** and validation.
- **Form validation** for all fields (frontend + backend).
- **Upon submission:**
  - Admin account is created as **inactive** (pending approval by superadmin or system).
  - Email confirmation is sent (optional: OTP or activation link).
  - Success modal informs user that registration is pending approval.

### 2. **Admin Login Flow**
- **User fills out login form** with email and password.
- **Remember me** option for persistent sessions.
- **Password visibility toggle** and forgot password link.
- **Social logins** (Google, Microsoft) as future enhancement (UI present).
- **Error modal** for invalid credentials.
- **Only active admin users can log in** (inactive = pending approval or suspended).

### 3. **Email/OTP Verification (Optional/Recommended)**
- **After registration**, send an OTP or activation link to admin's email.
- **OTP/activation link** expires after a set time (e.g., 10 minutes).
- **Verification page** for OTP input or link click.
- **Upon successful verification:**
  - Admin account is marked as verified and awaits approval (if required).
  - OTP is deleted from the database.
- **Resend OTP** functionality with cooldown to prevent abuse.

### 4. **Admin Approval (Manual or Automated)**
- **Superadmin reviews pending admin registrations**.
- **Approve/deny** actions available in the admin dashboard.
- **Email notification** sent to admin upon approval or denial.
- **Only approved and verified admins can access admin dashboard.**

### 5. **Security Features**
- **Password hashing** with Django's built-in mechanisms.
- **CSRF protection** on all forms.
- **Rate limiting** for login and OTP verification attempts.
- **Brute force protection** (recommend `django-axes` or similar).
- **All sensitive actions require HTTPS**.
- **Audit logging** for all admin authentication events (login, logout, failed attempts, registration).

### 6. **UI/UX Features**
- **Professional, branded design** consistent with Triple G BuildHub.
- **Responsive layout** for desktop and tablet.
- **Accessible forms** with clear labels, error messages, and ARIA attributes.
- **Toast/modal notifications** for feedback (success, error, info).
- **Password strength indicator** and visibility toggle.
- **Clear guidance** for next steps after registration and login.

### 7. **Database Structure**
- **Admin users** are stored in the same `auth_user` table, distinguished by `is_staff` and/or `is_superuser`.
- **Profile extension** (optional): Add admin-specific fields in a related `Profile` or `AdminProfile` model.
- **OTP table** for email verification if used.

### 8. **URLs & Views**
- `/accounts/admin/login/` — Login page
- `/accounts/admin/register/` — Registration page
- `/accounts/admin/verify-otp/` — OTP/email verification
- `/accounts/admin/logout/` — Logout
- **Views**: Use Django CBVs or FBVs with @transaction.atomic, CSRF, and security best practices.

### 9. **Email Configuration**
- **SMTP settings** for sending OTPs/confirmation emails.
- **Templated emails** for branding and clarity.
- **App password or secure credentials** for email backend.

### 10. **Testing & Quality Assurance**
- **Automated tests** for registration, login, OTP, approval, and edge cases.
- **Manual testing** for all flows and error scenarios.
- **Security testing** (rate limiting, brute force, session management).

### 11. **Future Enhancements**
- **Multi-factor authentication** (MFA) for admin logins.
- **Admin activity logs** and dashboards.
- **Role-based permissions** (superadmin, manager, staff).
- **Single Sign-On (SSO)** integration for enterprise environments.
- **reCAPTCHA** on registration and login to prevent bots.
- **SMS-based OTP** as an additional option.

---

**Summary:**  
This plan ensures the adminside authentication is robust, secure, and user-friendly, matching the standards set for your client-side system. It is ready for production with scalability and future enhancements in mind.