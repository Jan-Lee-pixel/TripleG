📌 accounts/models.py
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from datetime import timedelta
import random

class OneTimePassword(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    code = models.CharField(max_length=6)
    created_at = models.DateTimeField(auto_now_add=True)

    def is_expired(self):
        return timezone.now() > self.created_at + timedelta(minutes=10)

    @staticmethod
    def generate_code():
        return str(random.randint(100000, 999999))

📌 accounts/forms.py
from django import forms
from django.contrib.auth.models import User

class RegisterForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput)
    class Meta:
        model = User
        fields = ['username', 'email', 'password']

class OTPForm(forms.Form):
    otp = forms.CharField(max_length=6, required=True, label="Enter OTP")

📌 accounts/views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from django.core.mail import send_mail
from django.contrib.auth.models import User
from django.conf import settings

from .forms import RegisterForm, OTPForm
from .models import OneTimePassword

# Register View
def register(request):
    if request.method == "POST":
        form = RegisterForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.set_password(form.cleaned_data['password'])
            user.is_active = False
            user.save()

            # Generate OTP
            code = OneTimePassword.generate_code()
            OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

            # Send OTP via email
            send_mail(
                "Verify your Triple G account",
                f"Your OTP code is {code}. It will expire in 10 minutes.",
                settings.DEFAULT_FROM_EMAIL,
                [user.email],
                fail_silently=False,
            )

            messages.info(request, "Account created! Please verify with the OTP sent to your email.")
            request.session['pending_user_id'] = user.id
            return redirect("verify_otp")
    else:
        form = RegisterForm()
    return render(request, "accounts/register.html", {"form": form})


# OTP Verification View
def verify_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    otp_obj = OneTimePassword.objects.filter(user=user).first()

    if request.method == "POST":
        form = OTPForm(request.POST)
        if form.is_valid():
            code = form.cleaned_data['otp']
            if otp_obj and otp_obj.code == code and not otp_obj.is_expired():
                user.is_active = True
                user.save()
                otp_obj.delete()
                messages.success(request, "Account verified! You can now log in.")
                return redirect("login")
            else:
                messages.error(request, "Invalid or expired OTP.")
    else:
        form = OTPForm()
    return render(request, "accounts/verify_otp.html", {"form": form, "email": user.email})


# Resend OTP View
def resend_otp(request):
    user_id = request.session.get('pending_user_id')
    if not user_id:
        return redirect("register")

    user = User.objects.get(id=user_id)
    code = OneTimePassword.generate_code()
    OneTimePassword.objects.update_or_create(user=user, defaults={"code": code})

    send_mail(
        "Resend OTP - Triple G account",
        f"Your new OTP code is {code}. It will expire in 10 minutes.",
        settings.DEFAULT_FROM_EMAIL,
        [user.email],
        fail_silently=False,
    )

    messages.success(request, "A new OTP has been sent to your email.")
    return redirect("verify_otp")

📌 accounts/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path("register/", views.register, name="register"),
    path("verify-otp/", views.verify_otp, name="verify_otp"),
    path("resend-otp/", views.resend_otp, name="resend_otp"),
]

📌 templates/accounts/register.html
<h2>Create Account</h2>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Register</button>
</form>

📌 templates/accounts/verify_otp.html
<h2>Verify Account</h2>
<p>We sent an OTP to your email: {{ email }}</p>
<form method="POST">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Verify</button>
</form>

<p>Didn't receive the code? 
   <a href="{% url 'resend_otp' %}">Resend OTP</a>
</p>

📌 settings.py (Email setup for OTP)

Add this for email sending (use Gmail SMTP or service like SendGrid, Mailgun):

# Example: Gmail SMTP
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = "smtp.gmail.com"
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = "your-email@gmail.com"
EMAIL_HOST_PASSWORD = "your-app-password"  # Use app password, not your raw Gmail password
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER

🔒 Security Checklist

OTP expires in 10 minutes.

OTP is deleted once used.

Prevent brute force → consider libraries like django-axes.

Always deploy over HTTPS.

Emails should use App Passwords / secure SMTP.

✅ This gives you:

Register → inactive user created

OTP emailed

Verify OTP → activate user

Resend OTP option













📌 Descriptive Plan for Secure Registration with OTP Verification
1. User Registration Flow

A new user fills out the registration form (username, email, password).

When the form is submitted:

The password is hashed using Django’s set_password() method.

The user account is created but marked as inactive (user.is_active = False).

An OTP code is generated (6 digits, random).

The OTP is stored in the OneTimePassword model linked to the user.

An email is sent to the user with the OTP code and a message that it expires in 10 minutes.

The system saves the user’s ID in the session (request.session['pending_user_id']) so the verification step knows which user is pending activation.

2. OTP Verification Flow

The user is redirected to the OTP verification page.

They enter the OTP code into the form.

When submitted:

The system checks:

If the OTP exists for the user.

If the code matches.

If the OTP is not expired (older than 10 minutes → rejected).

If valid:

The user account is activated (user.is_active = True).

The OTP record is deleted from the database.

The user receives a success message and is redirected to the login page.

If invalid or expired:

An error message is shown (Invalid or expired OTP).

3. Resend OTP Flow

If the user doesn’t receive the OTP or it expires:

They click “Resend OTP” on the verification page.

A new 6-digit OTP is generated and updated in the database.

A new email is sent with the updated code.

The old code is automatically replaced.

The user is redirected back to the verification page with a success message.

4. Security Features

🔐 OTP Expiry → Each OTP is valid only for 10 minutes.

🔐 OTP Deletion → Once successfully used, the OTP record is deleted.

🔐 Inactive Until Verified → Users cannot log in until they successfully verify with OTP.

🔐 Brute Force Protection → Add optional libraries like:

django-axes (blocks repeated failed login attempts).

Rate limiting OTP verification attempts.

🔐 Secure Email Delivery →

Use Gmail App Passwords or services like SendGrid/Mailgun.

Never store plain email passwords in the code.

🔐 Transport Security → Always deploy with HTTPS (TLS) so credentials/OTPs aren’t intercepted.

5. User Experience (UX)

✅ Clear messages guide the user through registration and verification.

✅ Resend OTP option prevents frustration if an email is delayed.

✅ Success message after activation confirms account is ready.

✅ Minimal fields in the register form make it simple for users.

6. Future Improvements (Optional Enhancements)

📱 Add SMS OTP using services like Twilio for better reach.

🔄 Add Backup Verification (e.g., recovery email, secret questions).

📊 Track verification attempts to detect unusual activity.

🕒 Allow users to request OTP only after a cooldown (e.g., 30s – 1min) to prevent spamming.

🛡 Use reCAPTCHA on registration to reduce bot signups.

✅ Summary:
Your system will:

Register users as inactive.

Send OTP to email.

Require OTP verification before login.

Allow resending of OTP if needed.

Protect against brute force & ensure secure delivery.

---

### 🚀 Enhancements & Best Practices (Recommended)

**Brute Force Protection:**
- Implement libraries like `django-axes` to block repeated failed login or OTP attempts.
- Consider rate limiting OTP verification and resend attempts.

**Rate Limiting for OTP Resend:**
- Add a cooldown (e.g., 30–60 seconds) before a user can request another OTP.

**Logging & Monitoring:**
- Log failed OTP and login attempts for auditing and possible lockout after repeated failures.

**Email Improvements:**
- Use Django’s templated emails for branded, user-friendly OTP messages.
- Consider adding a warning if an OTP is about to expire.

**Testing:**
- Add automated tests for registration, OTP expiry, resend, and verification flows.

**User Feedback:**
- Alert users if they are close to OTP expiry or have requested too many resends.

**SMS Option (Optional):**
- Add SMS OTP using services like Twilio for broader reach.

**Backup Verification:**
- Consider supporting backup email or secret questions for account recovery.

**Cool-down for OTP Requests:**
- Prevent spamming by enforcing a delay between OTP requests.

**reCAPTCHA:**
- Add reCAPTCHA to registration to reduce bot signups.

**Transport Security:**
- Always deploy with HTTPS (TLS) to protect credentials and OTPs in transit.

**Summary:**
These enhancements will make your authentication system even more robust, user-friendly, and secure for production environments.